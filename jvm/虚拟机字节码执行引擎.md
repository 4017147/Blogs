## 执行引擎

* 物理机:执行引擎是直接建立在处理器、硬件、指令集和操作系统层面
* 虚拟机:执行引擎则是由自己实现的，因此可以自行制定指令集与执行引擎的结构体系，并且能够执行那些不被硬件直接支持的指令集格式

* 运行时栈帧结构

>栈帧:支持虚拟机进行方法调用和方法执行的数据结构,它是虚拟机运行时数据区中的虚拟机栈(Virtual Machine Stack)的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息.每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程<br>
>一个线程中的方法调用链可能会很长，很多方法都同时处于执行状态。对于执行引擎来
说，在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧

* 局部变量表

> 是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量<br>
> Java中占用32位以内的数据类型有boolean、byte、char、short、int、float、reference 和returnAddress 8种类型。前面6种不需要多加解释，读者可以按照Java语言中对应数据类型的概念去理解它们（仅是这样理解而已，Java语言与Java虚拟机中的基本数据类型是存在本质差别的),而第7种reference类型表示对一个对象实例的引用，虚拟机规范既没有说明它的长度，也没有明确指出这种引用应有怎样的结构<br>

```java
// 1. GC 结果
//[GC (System.gc())  68157K->66176K(251392K), 0.0009480 secs]
//[Full GC (System.gc())  66176K->66082K(251392K), 0.0059124 secs]
public class TestMain {
    public static void main(String[] args) {
        {
            byte[] placeholder = new byte[64 * 1024 * 1024];
        }
        System.gc();
    }
}
// 2. GC 结果
//[GC (System.gc())  68157K->66192K(251392K), 0.0008190 secs]
//[Full GC (System.gc())  66192K->546K(251392K), 0.0040344 secs]
public class TestMain {
    public static void main(String[] args) {
        {
            byte[] placeholder = new byte[64 * 1024 * 1024];
        }
        int a = 10;
        System.gc();
    }
}
// 3. GC 结果
//[GC (System.gc())  68157K->66160K(251392K), 0.0024962 secs]
//[Full GC (System.gc())  66160K->546K(251392K), 0.0043552 secs]
public class TestMain {
    public static void main(String[] args) {
        byte[] placeholder;
        {
            placeholder = new byte[64 * 1024 * 1024];
        }
        placeholder = null;
        System.gc();
    }
}
```
> 局部变量表中的Slot是否还存有关于placeholder数组对象的引用。第一次修改中，代码虽然已经离开了placeholder的作用域，但在此之后，没有任何对局部变量表的读写操作，placeholder原本所占用的Slot还没有被其他变量所复用，所以作为GCRoots一部分的局部变量表仍然保持着对它的关联。这种关联没有被及时打断

* 操作数栈

>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，
会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈/入栈操作<br>
> Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈

* 动态连接

>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为
了支持方法调用过程中的动态连接

* 方法调用

> 方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本
(即调用哪一个方法),暂时还不涉及方法内部的具体运行过程

* 分派

> 静态派发: 重载

```java
/**
 * 方法静态分派演示
 * 输出结果
 * hello,guy！
 * hello,guy！
 */
public class StaticDispatch {
    static abstract class Human {
    }

    static class Man extends Human {
    }

    static class Woman extends Human {
    }

    public void sayHello(Human guy) {
        System.out.println("hello,guy！");
    }

    public void sayHello(Man guy) {
        System.out.println("hello,gentleman！");
    }

    public void sayHello(Woman guy) {
        System.out.println("hello,lady！");
    }

    public static void main(String[] args) {
        Human man = new Man();
        Human woman = new Woman();
        StaticDispatch sr = new StaticDispatch();
        sr.sayHello(man);
        sr.sayHello(woman);
    }
}
```

>main()里面的两次sayHello方法调用,在方法接收者已经确定是对象“sr”的前提下,使用哪个重载版本，就完全取决于传入参数的数量和数据类型<br>
> 所有依赖静态类型来定位方法执行版本的分派动作称为静态分派<br>

```java
// 匹配方式：char-＞int-＞long-＞float-＞double的顺序转型进行匹配
public class Overload {
    public static void sayHello(Object arg) {
        System.out.println("hello Object");
    }

    public static void sayHello(int arg) {
        System.out.println("hello int");
    }

    public static void sayHello(long arg) {
        System.out.println("hello long");
    }

    public static void sayHello(Character arg) {
        System.out.println("hello Character");
    }

    public static void sayHello(char arg) {
        System.out.println("hello char");
    }

    public static void sayHello(char... arg) {
        System.out.println("hello char……");
    }

    public static void sayHello(Serializable arg) {
        System.out.println("hello Serializable");
    }

    public static void main(String[] args) {
        sayHello('a');
    }
}
```

> 动态派发: 它和多态性的另外一个重要体现--重写（Override）有着很密切的关联

* 动态类型语言支持

> 动态类型语言
> 什么是动态类型语言？动态类型语言的关键特征是它的类型检查的主体过程是在运行
期而不是编译期，满足这个特征的语言有很多，常用的包括：APL、Clojure、Erlang、
Groovy、JavaScript、Jython、Lisp、Lua、PHP、Prolog、Python、Ruby、Smalltalk和Tcl等

>运行时异常就是只要代码不运行到这一行就不会有问题。与运行时异常相对应的是连接时异常,例如很常见的NoClassDefFoundError便属于连接时异常，即使会导致连接时异常的代码放在一条无法执行到的分支路径上，类加载时（Java的连接过程不在编译阶段，而在类加载阶段）也照样会抛出异常